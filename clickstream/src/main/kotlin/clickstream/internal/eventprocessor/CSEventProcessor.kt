package clickstream.internal.eventprocessor

import clickstream.CSEvent
import clickstream.api.CSInfo
import clickstream.config.CSEventProcessorConfig
import clickstream.health.constant.CSEventNamesConstant
import clickstream.health.constant.CSEventTypesConstant
import clickstream.health.intermediate.CSHealthEventRepository
import clickstream.health.model.CSHealthEventDTO
import clickstream.internal.CSEventInternal
import clickstream.protoName
import clickstream.internal.eventscheduler.CSEventScheduler
import clickstream.logger.CSLogger
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.ExperimentalCoroutinesApi

/**
 * This is responsible for ingesting analytics events generated by app,adding relevant keys,
 * and forwarding the events to [CSEventScheduler].
 *
 * @param eventScheduler used for scheduling events
 * @param dispatcher used for dispatching events serially
 * @param logger used for logging
 * @param healthEventRepository used for tracking health events
 */
@ExperimentalCoroutinesApi
internal class CSEventProcessor(
    private val config: CSEventProcessorConfig,
    private val eventScheduler: CSEventScheduler,
    private val dispatcher: CoroutineDispatcher,
    private val logger: CSLogger,
    private val healthEventRepository: CSHealthEventRepository,
    private val info: CSInfo,
) {

    /**
     * Creates event object and forwards to EventScheduler.
     *
     * @param event [CSEvent] which holds guid, timestamp and message
     */
    suspend fun trackEvent(event: CSEventInternal) {
        logger.debug { "CSEventProcessor#trackEvent" }
        val (eventGuid, eventName) = when (event) {
            is CSEventInternal.CSEvent -> event.guid to event.message.protoName()
            is CSEventInternal.CSBytesEvent -> event.guid to event.eventName
        }

        logger.debug { "CSEventProcessor#trackEvent" }
        logHealthEvent(
            eventName = CSEventNamesConstant.Flushed.ClickStreamEventReceived.value,
            eventId = eventGuid.plus("_")
                .plus(eventName.toLowerCase())
        )

        when {
            config.realtimeEvents.contains(eventName) -> {
                eventScheduler.scheduleEvent(event)
            }
            config.instantEvent.contains(eventName) -> {
                eventScheduler.sendInstantEvent(event)
            }
            else -> {
                eventScheduler.scheduleEvent(event)
            }
        }
    }

    private suspend fun logHealthEvent(eventName: String, eventId: String) {
        healthEventRepository.insertHealthEvent(
            CSHealthEventDTO(
                eventName = eventName,
                eventType = CSEventTypesConstant.AGGREGATE,
                eventGuid = eventId,
                appVersion = info.appInfo.appVersion
            )
        )
    }
}
